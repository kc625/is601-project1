<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Four Core Principles of OOP</title>
    <meta name="description" content="This is an example of a meta description.
    This will often show up in search results.">

    <link rel="stylesheet" href="css/style.css">
    <style>
        #primaryLinks {
            height: 100px;
            margin: 0;
            line-height: 100px;
            width: 1000px;
            text-align: right;
            padding: 0;
        }
        #primaryLinks li {
            display: inline;
        }
        #primaryLinks menu {
            padding-top: 0;
            padding-left: 0;
        }
        #logo {
            font-size: x-large;
        }
        #logo img {
            width: 100px;
        }
        #primaryContent {
            width: 1000px;
            text-align: left;
            font-size: large;
        }
        #wrapper {
            width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }
        #footer {
            text-align: center;
            height: 20px;
            line-height: 20px;
        }
        .clearFix {
            clear: both;
        }
        .floatLeft {
            float: left;
        }
    </style>

</head>
<body>
<div id="wrapper">
    <div id="logo" class="floatLeft">
        <img src="images/fediverse_logo_proposal.svg" alt="An Interconnected World!"/>
        Python For Everyone!
    </div>
    <menu id="primaryLinks">
        <li><a href="index.html">Pylint Tips & Tricks</a></li>
        <li>|</li>
        <li><a href="page_two.html">AAA Testing</a></li>
        <li>|</li>
        <li><a href="page_three.html">OOP Principles</a></li>
        <li>|</li>
        <li><a href="page_four.html">Separation of Concerns</a></li>
    </menu>
    <hr>
    <h1>The Four Core Principles of Object-Oriented Programming</h1>
    <article id="primaryContent">
        <hr>
        <h2>What are the Four Core Principles?</h2>
        <p>
            Object-Oriented Programming (OOP) can be a powerful tool when implemented properly. In order for us to make sure we are utilizing it to its fullest extent, we have to be sure we are sticking to the four fundamental concepts of OOP. These are also known as the four core principles. These principles are Encapsulation, Inheritance, Polymorphism, and Abstraction. The rest of this article will define what each of these terms mean, as well as show how our Calculator program utilizes them all.
        </p>
        <h3>Encapsulation</h3>
        <p>
            Encapsulation is the idea of wrapping data and the methods that work on that data within one unit. This way there are restrictions placed on accessing variables and methods directly. This is useful as it can prevent accidental modifications of data. With encapsulation, an object's variable can only be changed by a method from that same object. A class is an example of encapsulation, as it bundles methods and data into a singular unit.
        </p>
        <h3>Inheritance</h3>
        <p>
            Act on the target behavior. This step should be utilizing the main thing that we are testing. This could be calling a function or a method for one example. It should stay focused on the target behavior.
        </p>
        <h3>Polymorphism</h3>
        <p>
            Assert expected outcomes. The actions you took during the Act step should generate some sort of response or outcome. The assert step verifies whether that outcome is what we were expecting to get. This assertion step is ultimately what decides whether the test passes or fails.
        </p>
        <h3>Abstraction</h3>
        <p>
            Test Test Test
        </p>
        <h2>Unit Testing</h2>
        <p>
            I would like to use the AAA method on a unit test to verify that our Calculator program works as intended. I will first start with our Addition class. Reminder that our Addition class (like our subtraction, multiplication, and division classes) inherits our Calculation class. The code for both of them is as follows:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                class Calculation:

                def __init__(self, values: tuple):
                self.values = Calculation.convert_args_to_tuple_of_floats(values)

                @classmethod
                def create(cls, values: tuple):
                return cls(values)

                @staticmethod
                def convert_args_to_tuple_of_floats(values):
                list_values_float = []
                for item in values:
                list_values_float.append(float(item))
                return tuple(list_values_float)


                class Addition(Calculation):

                def get_result(self):
                total_sum = 0.0
                for value in self.values:
                total_sum = total_sum + value
                return total_sum
            </code>
        </p>
        <p>
            The Calculation class takes a set of values and transforms them into a tuple of floats. Then an object of the Calculation class gets passed to the Addition class, which loops through the values in that tuple and adds them all together. Then we have an <code>add_numbers</code> method of our Calculator class, which takes a user input and passes it through all the way to Addition. Or at least, that's what we are expecting to happen! Let's build a test to find out if we are right.
        </p>
        <p>
            First, we'll define our test function. For Pylint to recognize it the name must begin with "test." We also want it to be easily understood which function we are testing, and since we are testing the static method from our Caclculator class called <code>add_numbers</code>, we'll define our test function in the following way:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                def test_calculator_add_static():
            </code>
        </p>
        <p>
            We want to make sure our calculator's history is empty before beginning our test, as existing values in the history could give us unexpected results. To do that, we will create a fixture for pytest that will be passed into our test function. This fixture will call the <code>clear_history</code> method from the Calculator's Calculations to give us the blank history we wish to start with. This will give us the following:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                @pytest.fixture
                def clear_history_fixture():
                Calculations.clear_history()

                def test_calculator_add_static(clear_history_fixture):
            </code>
        </p>
        <p>
            Now we will need to fill out the body of our test function, keeping AAA in mind. First, we Arrange by creating a tuple we are going to pass as a parameter.
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                @pytest.fixture
                def clear_history_fixture():
                Calculations.clear_history()

                def test_calculator_add_static(clear_history_fixture):
                <span style="color: green">#Arrange</span>
                my_tuple = (1.0, 3.0, 5.0)
            </code>
        </p>
        <p>
            Next, we Act by calling the Calculator's <code>add_numbers</code> method and passing it the tuple we just created.
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                @pytest.fixture
                def clear_history_fixture():
                Calculations.clear_history()

                def test_calculator_add_static(clear_history_fixture):
                <span style="color: green">#Arrange</span>
                my_tuple = (1.0, 3.0, 5.0)
                <span style="color: green">#Act</span>
                Calculator.add_numbers(my_tuple)
            </code>
        </p>
        <p>
            Finally, we Assert that our Addition is working as intended by getting the result to our last calculation and checking to see if it equals what we expect it to.
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                @pytest.fixture
                def clear_history_fixture():
                Calculations.clear_history()

                def test_calculator_add_static(clear_history_fixture):
                <span style="color: green">#Arrange</span>
                my_tuple = (1.0, 3.0, 5.0)
                <span style="color: green">#Act</span>
                Calculator.add_numbers(my_tuple)
                <span style="color: green">#Assert</span>
                assert Calculator.get_last_result_value() == 9.0
            </code>
        </p>
        <p>
            This test passes, as <code>1.0 + 3.0 + 5.0</code> does in fact equal nine. Therefore we know our Addition class is working correctly! Now we can do the same with our Subtraction, Multiplication, and Division classes to ensure that they are also working as intended. As long was follow the Arrange-Act-Assert format for our tests, we know that we are following best practices and covering all of our testing bases.
        </p>
    </article>
    <hr>
    <footer id="footer" class="clearFix">
        <p>
            <a href="https://commons.wikimedia.org/w/index.php?curid=70845534">"File:Fediverse logo proposal.svg"</a><span> by <a href="https://commons.wikimedia.org/wiki/User:Eukombos">Eukombos</a></span> is licensed under <a href="http://creativecommons.org/publicdomain/zero/1.0/deed.en?ref=ccsearch&atype=html">CC0 1.0</a>
        </p>
        <p>
            <a href="https://github.com/kc625/is601-project1">Link to GitHub Repository for this Project</a>
        </p>
        <img src="images/w3c.png" alt="W3C Validated"/>
    </footer>
</div>
</body>
</html>