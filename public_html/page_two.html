<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AAA Testing Tutorial</title>
    <meta name="description" content="This is an example of a meta description.
    This will often show up in search results.">

    <link rel="stylesheet" href="css/style.css">
    <style>
        #primaryLinks {
            height: 100px;
            margin: 0;
            line-height: 100px;
            width: 1000px;
            text-align: right;
            padding: 0;
        }
        #primaryLinks li {
            display: inline;
        }
        #primaryLinks menu {
            padding-top: 0;
            padding-left: 0;
        }
        #logo {
            font-size: xx-large;
        }
        #logo img {
            width: 100px;
        }
        #primaryContent {
            width: 1000px;
            text-align: left;
            font-size: large;
        }
        #wrapper {
            width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }
        #footer {
            text-align: center;
            height: 20px;
            line-height: 20px;
        }
        .clearFix {
            clear: both;
        }
        .floatLeft {
            float: left;
        }
    </style>

</head>
<body>
<div id="wrapper">
    <div id="logo" class="floatLeft">
        <img src="images/fediverse_logo_proposal.svg" alt="An Interconnected World!"/>
        Python For Everyone!
    </div>
    <menu id="primaryLinks">
        <li><a href="index.html">Pylint Tips & Tricks</a></li>
        <li>|</li>
        <li><a href="page_two.html">AAA Testing</a></li>
        <li>|</li>
        <li><a href="page_three.html">OOP Principles</a></li>
        <li>|</li>
        <li><a href="page_four.html">Separation of Concerns</a></li>
    </menu>
    <hr>
    <h1>A tutorial on AAA Testing</h1>
    <article id="primaryContent">
        <hr>
        <h2>AAA: Arrange, Act, Assert</h2>
        <p>
            When coding, it is necessary to test your program before deploying it. Testing our code allows us to make sure that the program is behaving the way we're expecting it to. Not using tests can be dangerous, as our code could be doing something totally unexpected without us knowing. So we definitely want to make tests. But how do we make good tests? One tried and true method is to follow this simple pattern: Arrange, Act, Assert.
        </p>
        <h3>Arrange</h3>
        <p>
            Arrange the inputs and targets. This step sets up the test case. Does the test require any objects to be instantiated or inputs to be created? This is where you set the stage for the rest of the test.
        </p>
        <h3>Act</h3>
        <p>
            Act on the target behavior. This step should be utilizing the main thing that we are testing. This could be calling a function or a method for one example. It should stay focused on the target behavior.
        </p>
        <h3>Assert</h3>
        <p>
            Assert expected outcomes. The actions you took during the Act step should generate some sort of response or outcome. The assert step verifies whether that outcome is what we were expecting to get. This assertion step is ultimately what decides whether the test passes or fails.
        </p>
        <h2>Unit Testing</h2>
        <p>
            I would like to use the AAA method on a unit test to verify that our Calculator program works as intended. I will first start with our Addition class. Reminder that our Addition class (like our subtraction, multiplication, and division classes) inherits our Calculation class. The code for both of them is as follows:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
        class Calculation:

            def __init__(self, values: tuple):
                self.values = Calculation.convert_args_to_tuple_of_floats(values)

            @classmethod
            def create(cls, values: tuple):
                return cls(values)

            @staticmethod
            def convert_args_to_tuple_of_floats(values):
                list_values_float = []
                for item in values:
                    list_values_float.append(float(item))
                return tuple(list_values_float)


        class Addition(Calculation):

            def get_result(self):
                total_sum = 0.0
                for value in self.values:
                    total_sum = total_sum + value
                return total_sum
            </code>
        </p>
        <p>
            The Calculation class takes a set of values and transforms them into a tuple of floats. Then an object of the Calculation class gets passed to the Addition class, which loops through the values in that tuple and adds them all together. Then we have an <code>add_numbers</code> method of our Calculator class, which takes a user input and passes it through all the way to Addition. Or at least, that's what we are expecting to happen! Let's build a test to find out if we are right.
        </p>
        <h3>Line Too Long</h3>
        <p>
            Pylint gives you a <code>line-too-long</code> error if any line of your code has greater than 100 characters in it. When we are coding, we should aim to accomplish our goal as succinctly as possible. This is true for total lines of code, as well as how long each line is. You are likely to see this error in reference to a line that contains a docstring. In that case, simply shorten the description within your docstring so that it is under the recommended 100-character limit. If it is referencing a line that contains actual code, perhaps consider alternate ways of achieving the same outcome. Preferably with more, but shorter, lines of code.
        </p>
        <h3>Unused Variable</h3>
        <p>
            Within the functions we create, we often have the ability to define and use variables. If we are not careful though, we may accidentally create variables that we do not actually use within the function. Consider the following block of code:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                @staticmethod
                def convert_args_to_tuple_of_floats(values):
                """Standardizes values to a tuple of floats"""
                list_values_float = []
                <span style="color: red">unnecessary_list = []</span>
                for item in values:
                list_values_float.append(float(item))
                return tuple(list_values_float)
            </code>
        </p>
        <p>
            If we had this function in our program, Pylint would give us an <code>unused-variable</code> error. Notice the list variable we created that is highlighted in red, <code>unnecessary_list</code>. After defining it, we do not use it for the rest of the function. If that variable was removed, this function would produce the same output and have the same functionality to users. To resolve this error, we should remove the unused variable completely.
        </p>
        <h3>Invalid Name</h3>
        <p>
            Pylint prefers we use the naming convention known as snake case when naming our variables, functions, etc. as opposed to other popular conventions like camel case. If you receive an <code>invalid-name</code> error from Pylint, one of your functions or variables is likely named in camel case. What's the difference? This is one of our functions named in camel case: <code>getLastCalculationResult()</code>. This is the same function named in snake case: <code>get_last_calculation_result()</code>. Do you see how, thanks to the underscores present, the latter is a bit clearer and easier to read? This is especially true the longer a variable or function name is. This is why Pylint prefers snake case.
        </p>
        <h3>Unnecessary Else Statement</h3>
        <p>
            Consider the following function that is a part of our Division class:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                def get_result(self):
                """This does the actual division. Displays an error if dividing by 0"""
                quotient = self.values[0]
                for value in self.values[1:]
                if value == 0.0:
                return "Error, cannot divide by zero."
                else:
                quotient = quotient / value
                return quotient
            </code>
        </p>
        <p>
            This function takes a tuple of floats as a parameter and sets a variable equal to the first value of the tuple. It then loops through the rest of the values and checks to see if they are equivalent to 0. If the value is, it returns an error message. If it isn't, the function divides the first value by each consecutive value. However, if we use this function in a program, Pylint gives us a <code>no-else-return</code> error. What does this mean? Pylint is trying to tell us that the <code>else</code> is actually unnecessary, as it is redundant. Should <code>if value == 0.0</code> be evaluated as false, our program will move on to <code>quotient = quotient / value</code> regardless of whether the actual <code>else</code> is present or not. So for the sake of brevity, we can cut that line out of our code, and the following, more streamlined version of the function would work exactly the same:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                def get_result(self):
                """This does the actual division. Displays an error if dividing by 0"""
                quotient = self.values[0]
                for value in self.values[1:]
                if value == 0.0:
                return "Error, cannot divide by zero."
                quotient = quotient / value
                return quotient
            </code>
        </p>
        <h3>Disabling Pylint Errors</h3>
        <p>
            Another important thing to know is how to disable an error that Pylint is giving you. This is something that should only be done sparingly, as most of the time Pylint's suggestions are very helpful for us. However, Pylint does not always know what is best. For example, when testing our Calculation class, we receive an error from Pylint stating <code>too-few-public-methods</code>. What this error means, is that Pylint feels our Calculation class does not have enough usable methods to make it worthwhile. It wants us to either add more methods to give the class more functionality, or find another way to accomplish the same as <code>Calculation</code> but without a class. But like I said, Pylint does not always know what is best, and we definitely want to use a class here. It also has all the functionality we need, so we don't have to add more methods to it. In this situation, we can disable the <code>too-few-public-methods</code> error that Pylint is giving us. To do so, we simply enter a comment with a specific wording that Pylint will recognize. We add it where Pylint is suggesting the error is occurring. In this case, that would be right after defining the class. It would look like the following, with our disable comment highlighted in green:
        </p>
        <p>
            <code style="display:block; white-space:pre-wrap">
                class Calculation:
                """Abstract Base Class used for the other calculations"""
                <span style="color: green"># pylint: disable=too-few-public-methods</span>

                ...
            </code>
        </p>
    </article>
    <hr>
    <footer id="footer" class="clearFix">
        <p>
            <a href="https://commons.wikimedia.org/w/index.php?curid=70845534">"File:Fediverse logo proposal.svg"</a><span> by <a href="https://commons.wikimedia.org/wiki/User:Eukombos">Eukombos</a></span> is licensed under <a href="http://creativecommons.org/publicdomain/zero/1.0/deed.en?ref=ccsearch&atype=html">CC0 1.0</a>
        </p>
        <p>
            <a href="https://github.com/kc625/is601-project1">Link to GitHub Repository for this Project</a>
        </p>
        <img src="images/w3c.png" alt="W3C Validated"/>
    </footer>
</div>
</body>
</html>